\input{praeambel.tex} % Importiere die Einstellungen aus der Präambel
% hier beginnt der eigentliche Inhalt
\begin{document}
\pagenumbering{Roman} % Seitennummerierung mit großen römischen Zahlen 
\pagestyle{empty} % keine Kopf- oder Fußzeilen auf den ersten Seiten

% Titelseite
\clearscrheadings\clearscrplain
\begin{center}
\begin{Huge}
Entwicklung eines dreidimensionalen zyklischen Dungeon-Generators mit Unity3D\\
\end{Huge}
\vspace{8mm}
Bachelorarbeit\\
\vspace{0.4cm}
\vspace{2 cm}
Nils Gawlik \\
Matrikel-Nummer 553449\\
\vspace{8cm}
\begin{tabular}{rl}
{\bfseries Betreuer} & Prof. Lenz \\
{\bfseries Erstprüfer}& Prof. Lenz\\
{\bfseries Zweitprüfer}& Prof. Strippgen\\
\end{tabular}

\end{center}
\clearpage


\pagestyle{useheadings} % normale Kopf- und Fußzeilen für den Rest

\tableofcontents % erstelle hier das Inhaltsverzeichnis
\listoffigures % erstelle hier das Abbildungsverzeichnis
\clearpage

% richtiger Inhalt
\pagenumbering{arabic} % ab jetzt die normale arabische Nummerierung
\chapter{Einführung und Definitionen}

\section{Motivation}

In einem Blog Post von 2016 beschreibt Joris Dormans einen Ansatz zur prozeduralen Level-Generierung, den er „Cyclic Dungeon Generation“ nennt. Dieses Verfahren präsentiert er als Gegensatz zu den Verzweigungs-Ansätzen die man in vielen anderen Dungeon-Generatoren findet \cite{blogCyclic}.

Zyklische Ansätze haben viele praktische Vorteile gegenüber Verzweigungs-Ansätzen. Zum einen vermeiden sie Sackgassen und damit verbundenes Backtracking und zum anderen ermöglichen sie das Generieren von typisch zyklischen Strukturen, unter anderem: „Einbahnstraßen“ mit anderem Rückweg, alternative Wege, Abkürzungen und direkte Rückkehr zum Startpunkt des Dungeons 
\cite{blogCyclic}.

Dormans Spiel „Unexplored“, dass im Blog Post als Beispiel verwendet wird, ist ein zweidimensionales Spiel in einer Top-Down-Perspektive. Besonders für zyklische Generierung ist es aber auch interessant einen dreidimensionalen Raum zu nutzen, da dies interessante Strukturen ermöglicht wie Brücken die bereits besuchte Teile des Dungeons überspannen.  

Das Ziel dieser Bachelorarbeit ist es ein Verfahren zur zyklischen Generierung von Dungeons zu konzipieren und zu implementieren. Dieses Verfahren sollte im dreidimensionalen Raum funktionieren und die dritte Dimension für interessante Strukturen nutzen können. Die Implementierung findet in der Game Engine Unity3D statt.

\todo{Quelle finden, dass viele designte Dungeons Zyklen aufweisen}


\section{Genaue Beschreibung der Fragestellung}

Der Inhalt der Arbeit ist die Entwicklung eines dreidimensionalen zyklischen Dungeon-Generators mit Unity3D. 

Im Folgenden soll erläutert werden, was unter Dungeons zu verstehen ist und wie die Einschränkungen „dreidimensional“ und „zyklisch“ im Kontext dieser Arbeit zu verstehen sind.

% \section{Dungeons}
\subsection{Definition von Dungeon}

Der englische Begriff „Dungeon“ wurde für diese Arbeit bewusst gewählt, er hat im Bereich Spiele eine Bedeutung, die sich von der wörtlichen Übersetzung „Verlies, Kerker“ unterscheidet. Eine einheitliche Definition für Dungeon in diesem Kontext existiert nicht, aber üblicherweise bezeichnet er einen weitläufigen, in sich geschlossenen Raum gefüllt mit Fallen und Monstern, den ein oder mehrere Spieler navigieren müssen, häufig mit einer großen Herausforderung am Ende, z.B. einem besonders starken Boss-Monster.

\bild{Warreks_Nest}{8cm}{Beispiel eines Dungeons \citeimg{warreksNestMap}}{Dungeon-Beispiel}

Dungeons haben auch eine Tradition prozeduraler Generierung. \todotext{later}

% \subsection{Wichtige Beispiele von Dungeons}

% Dungeons ist in einigen der populärsten Spielen vertreten. Beispiele sind „Dungeons \& Dragons“, „The Legend Of Zelda“, „The Elder Scrolls“ und „Minecraft“.

% \todo{Eine gute Auswahl finden, Bilder-Collage machen und einfügen}

% \subsection{Prozedurale Dungeon-Generierung in Spielen, Geschichte}

% In Computerspielen gibt es eine relativ lange Tradition der Dungeon-Generierung.

% \todo{Research Rougelikes, Roguelites, TES Oblivion}

\subsection{Definition von zyklisch}\label{c.weitereskapitel}

Der Begriff zyklisch ist als deutsches Äquivalent des englischen Begriffs „cyclic“ zu verstehen und ist aus dem bereits erwähnten Blog Post von Joris Dormans \cite{blogCyclic} übernommen. 

Für diese Arbeit wird folgende Definition verwendet: Ein Dungeon-Generator is zyklisch wenn A) der generierte Dungeon Zyklen enthält und B) Zyklen als Bausteine während der Generierung dienen.

\bild{Warrek_Graph}{8cm}{Bild eines Dungeons, mit möglichem Level-Graph, der Graph ist ungewichtet und ungerichtet (\citeimg{warreksNestMap}, bearbeitet)}{Dungeon-Beispiel mit Graph}

Zyklen im Dungeon erkennt man am Level-Graph, ist der Level-Graph zyklisch, so ist auch der Dungeon zyklisch. Betrachtet man das Beispiel in Abbildung \ref{img.Warrek_Graph} kann man mehrere Zyklen erkennen. Praktisch gesehen bedeutet das, dass der Spieler im Kreis laufen kann. Die Übersetzung der Level-Geometrie in einen Graphen ist nicht eindeutig - es sind mehrere Graphen möglich, aber der Graph sollte die Topologie des Raumes wiedergeben. \todo{Evtl. etwas zu topologischer Graphentheorie schreiben}

In der Realität kommt es selten vor, dass man beurteilen muss ob ein bereits existierender Dungeon zyklisch ist oder nicht. Häufiger ergibt sich ein Level-Graph während der Generierung, z.B. indem kontinuierlich Räume hinzugefügt werden. Die Räume können als Knoten, die Verbindungen zwischen den Räumen als Kanten verstanden werden.

Der Bedingung, dass Zyklen während der Generierung als Bausteine des Dungeons dienen, ist wichtig. So wird von einer anderen Art der Generierung unterschieden, wie man sie auch häufig in Level-Generatoren findet: Man generiert ein Labyrinth ohne Zyklen mit einem Verzweigungs-Ansatz und fügt anschließend willkürlich Verbindungen zwischen Räumen hinzu, bzw. - etwas bildlicher - „reißt Wände ein“. So entstehen auch Zyklen, diese sind aber willkürlich und schlecht kontrollierbar. 

Sind allerdings die Zyklen ein Baustein des Dungeons, so dass mehrere vordefinierte Arten von Zyklen durch Aneinanderreihung oder Verschachtelung kombiniert werden, hat man Kontrolle über die Natur der Zyklen. Variablen wie Größe, Richtung und Anordnung der Zyklen sind direkt konfigurierbar.

\subsection{Dreidimensionalität}

Dreidimensionalität bedeutet im Kontext dieser Arbeit, dass alle generierten Strukturen räumlich sind. Ein Spieler kann sich durch den Dungeon sowohl parallel zum Boden als auch vertikal (z.B. über Treppen oder Leitern bewegen). Es soll die Möglichkeit bestehen, dass Strukturen über andere Strukturen hinwegführen.

\section{Die Unity Game Engine}

Unity ist eine Game Engine für die Entwicklung von 2D und 3D-Spielen. 

Es wurde eine Game Engine verwendet, um den Implementierungs-Teil der Arbeit auf den Generator selbst und das User-Interface des Generators zu beschränken. Die Implementierung von Engine-typischen Features wie Rendering oder Kollision soll nicht Teil der Arbeit sein.

Die Wahl einer Game Engine für ein bestimmtes Projekt ist immer auch eine subjektive Entscheidung. Hauptargumente für Unity sind die weite Verbreitung der Game Engine unter Indie-Entwicklern, das Entity-Component-System, dass einen modularen Aufbau ermöglicht und das Editor Scripting, dass es erlaubt ein User Interface für den Generator innerhalb der Engine zu schreiben. 

\chapter{Der Ersetzungs-Algorithmus}

Im Folgenden wird der der Arbeit zugrunde liegende Algorithmus theoretisch erklärt.

\section{Formale Grammatiken und Graphgrammatiken für die Generierung}

Dem Algorithmus liegt ein Ersetzungssystem zu Grunde. Dieses ähnelt der Generierung durch eine Graphgrammatik, weswegen kurz auf die Prozedurale Generierung mit Hilfe von Formalen Grammatiken und im speziellen Graphgrammatiken eingegangen wird.

Formale Grammatiken werden in der prozeduralen Generierung gerne verwendet um Wörter und Texte zu generieren oder andere eindimensionale Ketten von Symbolen, wie z.B. Melodien. „Procedural Content Generation In Games“ sagt folgendes:

„Generative grammars were originally developed to formally describe structures in natural language. These structures—phrases, sentences, etc.—are modelled by a finite set of recursive rules that describe how larger-scale structures are built from smaller-scale ones, grounding out in individual words as the terminal symbols.“
\cite[Kap.~3.5, S.~45]{shaker2016procedural}

Damit eine nicht-deterministische Grammatik zur Generierung verwendet werden kann muss eine Entscheidung getroffen werden, in welcher Reihenfolge Regeln angewendet werden. Eine mögliche Methode ist jeden Generations-Schritt eine zufällige Regel aus der Menge an anwendbaren Regeln auszuwählen. 
\cite[Kap.~5.2, S.~75]{shaker2016procedural}
Eine Terminierung des Algorithmus ist hier nicht garantiert, da Regeln rekursiv sein können. Aber bei einer zufälligen Auswahl ist eine Terminierung in einer akzeptablen Laufzeit sehr wahrscheinlich, angenommen die Formale Sprache enthält keine rekursiven Regeln ohne Abbruchbedingung. 

Eine Graphgrammatik verhält sich wie eine Formale Grammatik, allerdings sind die linken und rechten Seiten hier Mustergraphen. Hierbei ist es wichtig, dass die individuellen Knoten auf der linken Seite jeweils individuelle Knoten auf der rechten Seite zugewiesen werden können, damit die Ersetzung stattfinden kann. 
\cite[Kap.~5.5.1, S.~80]{shaker2016procedural}
Durch widerholte Ersetzung von Teilgraphen kann hier aus einem Start-Graph ein End-Graph erzeugt werden. Die Menge der produzierbaren Graphen bildet die durch die Graphgrammatik definierte Formale Sprache. 

In \cite{dormansAdventures} benutzt Dormans Graphgrammatiken um Missionsstrukturen zu generieren und Figur-Grammatiken (engl. Shape Grammars) um den zugehörigen Raum zu generieren. Diese Missionsstrukturen sind zyklisch, der Raum allerdings nicht.

\section{Spezieller Algorithmus}\label{s.speziellerAlgorithmus}

Der Generator den ich diese Bachelorarbeit entwickelt habe, ist durch wiederholte Iteration und Experimentation entstanden. Diese Implementierung wird später ausführlich in Kapitel \ref{c.implementierung} beschrieben.

Aber zum klareren Verständnis will ich zunächst den spezielleren Algorithmus formal beschreiben, und in 
\ref{s.allgemeinerAlgorithmus} bei einer Verallgemeinerung ankommen. 

Wie bereits erwähnt ähnelt das Verfahren einer Graphgrammatik. Es ist inspiriert von Joris Dormans Ansatz in 
\cite{dormansAdventures},
allerdings werden keine separaten Modelle für Missionsstruktur und Raum verwendet.
In \cite[2.]{dormansModelTransformation} geht Dormans genauer auf „mission and space“ ein und dass diese beiden Modelle von Level-Designern häufig als isomorphisch angenommen werde. Er argumentiert jedoch, dass sie als separate Modelle verstanden werden sollten. Mission bezeichnet dabei ein Modell der Aufgaben die der Spieler bewältigen muss, Space bezeichnet den Raum in dem diese Aufgaben ausgeführt werden müssen.

Für mein Verfahren wurden keine separaten Modelle für Mission und Space verwendet, sondern direkt ein Raum generiert, der eine Missionsstruktur implizit beinhaltet. Für die Zwecke dieser Arbeit, wurde diese Vereinfachung als „gut genug“ befunden.

Der Generierung dieses Raumes würde ich mich gerne über das bereits bekannte Konzept der Graphgrammatik annähern. Hierfür stelle man sich einen mit Hilfe einer Graphgrammatik generierten Level-Graph vor. Dieser ist allerdings an ein dreidimensionales kartesisches Gitter gebunden. Verbindungen zwischen Knoten des Graphen sind nur zwischen direkt (nicht diagonal) benachbarten Zellen möglich, wie in Abbildung \ref{img.gridExample3D} dargestellt.

\bild{gridExample3D}{6cm}{Beispiel für einen dreidimensionalen Graph innerhalb der Restriktionen des Gitters}{Beispiel für Graph im Gitter}

Zu Jedem Knoten und den mit ihm verbundenen Kanten kann man sich einen äquivalenten Raum vorstellen. Als Verbindung zwischen den Räumen dient ein Ausgang, die äquivalent zu einer halben Kante ist (siehe Abb. \ref{img.nodeToRoom}).

\bild{nodeToRoom}{8cm}{Knoten mit Halb-Kanten und äquivalenter Raum}{Äquivalenz von Knoten und Raum}

Würde man einen solchen Raum, der genau eine Gitterzelle einnimmt für alle Ausrichtungen manuell entwerfen, etwa in einem 3D-Programm, so würden $ 2^6 = 64 $ verschiedene Raum-Vorlagen benötigt, da es sechs Ausgänge pro Raum gibt, die jeweils zwei Zustände („Tür“ oder „keine Tür“) haben können. Durch geschicktes nutzen von Rotationssymmetrie könnte man diese Zahl verringern, dennoch ist dies nicht ideal, da ein Level-Designer trotzdem eine Mindestzahl an Räumen entwerfen müsste. Außerdem will man für einen abwechslungsreichen Dungeon verschiedene „Themes“ haben, verschiedene Arten von Raumübergängen und andere Arten von Variationen. Diese Variationen kann man nicht alle in allen möglichen Raumvariationen bereitstellen. 

Alternativ könnte man auch die einzelnen Räume prozedural generieren. Dieser Ansatz wurde ausgetestet, aber nicht weiter verfolgt, da die Räume dadurch zu gleich aussahen, wie man in Abbildung \ref{img.voxelRoomDungeon} sehen kann. Einen abwechslungsreichen Raum-Generator zu entwickeln ist ein interessantes Problem, aber nicht Inhalt dieser Arbeit.

\bild{voxelRoomDungeon}{16cm}{Screenshot einer frühen Version des Generators mit prozedural generierten Räumen. Die Räume sehen sehr ähnlich aus.}{Generator mit prozeduralen Räumen} 

Die Lösung dieses Problems ist die Umformulierung des Modells. Anstatt einen Level-Graphen zu generieren, und diesen in einem zweiten Schritt in Räume zu übersetzen, werden die Räume direkt produziert. 

Dies bedeutet, dass keine Graphgrammatik im eigentlichen Sinne verwendet wird sondern stattdessen eine dreidimensionale Array-Grammatik. 

Für diesen Algorithmus wird eine Array-Grammatik verwendet, deren Produktionsregeln als linke und rechte Seite gleich große dreidimensionale Arrays haben. Ein Vorkommen der linken Seite kann durch die zugehörige rechte Seite ersetzt werden. Im Folgenden wird außerdem nicht zwischen Terminal- und Nichtterminalsymbolen unterschieden. Dies hat den Zweck, dass man die Generierung zu jeder Zeit abbrechen kann, und trotzdem eine korrekte Dungeon-Darstellung hat. Eine Unterscheidung von Terminalen und Nichtterminalen wäre aber einfach vorstellbar.

\bild{ruleExample1}{8cm}{Beispiel einer Produktionsregel\footnotemark}{Beispiel einer Produktionsregel}

\footnotetext{Arrays werden im Folgenden in 2D dargestellt, um die Grafiken übersichtlicher zu gestalten, sämtliche Grafiken gelten im gleichen Maße für dreidimensionale Arrays}

Anders als bei eindimensionalen Grammatiken wo sich die länge des Wortes bei der Ersetzung ändern kann, ändert sich die Größe des Arrays dabei nicht, da linke und rechte Seite gleich groß sind, es wird lediglich das relevante Teilstück ersetzt.

\bild{replaceExample1}{8cm}{Anwendung der Produktionsregel A (eine von drei möglichen Positionen der Anwendung)}{Beispiel einer Regelanwendung}

Um mit dieser Array-Grammatik einen Dungeon zu erstellen müssen wir lediglich statt einem Alphabet aus Buchstaben ein Alphabet aus Raumteilen verwenden. Verwendet man ein solches Alphabet, so kann eine Graphgrammatik implizit in den Arrays enthalten sein, wie in Abbildung \ref{img.ruleExample2} illustriert. In der Praxis sind diese Raumteile 3D Modelle, die modular zusammenpassen und so kann ein ganzer Dungeon mit Regeln transformiert werden.

Hierbei ist dem Autor/der Autorin der Regeln überlassen, dass die Regeln selbst einen korrekten Dungeon produzieren. Eine Regel, die z.B. eine Verbindung ins Nichts führen lässt sollte nicht erstellt werden. 

Ein großer Vorteil dieser Methode ist, dass das Alphabet aus beliebig vielen oder wenigen Raumteilen bestehen kann. Symbole für verschiedene Rotationen des gleichen Modells können automatisch erzeugt werden.

\todo{Bild aus der Implementierung nehmen}

\bild{ruleExample2}{10cm}{Alphabet $\Sigma$ mit Level-Graph-Teilen und einer Produktionsregel $R$}{Beispiel einer Produktionsregel aus Levelteilen}

\section{Allgemeiner Algorithmus}\label{s.allgemeinerAlgorithmus}

Der in Abschnitt \ref{s.allgemeinerAlgorithmus} beschriebene Algorithmus ist der in der Implementierung verwendete. 

Im Folgenden will ich diesen allerdings zu akademischen Zwecken (\todo{really?}) verallgemeinern.

$ G = (V, T, P, S) $

$ V $ ist die Symbolmenge 

$ T \subset V $ ist die Menge der Terminalsymbole

$ P \subset (V^\ast \setminus t^\ast) \times V^\ast $ ist die Menge der Produktionsregeln

$ X^\ast $ 



\todo{Mache ich später, wenn platz und bock. :P}

\chapter{Implementierung}\label{c.implementierung}

In diesem Kapitel wird die praktische Umsetzung des in \ref{s.speziellerAlgorithmus} beschriebenen Algorithmus behandelt. Die Implementierung beinhaltet viele einzelne Komponenten und Konfigurationsmöglichkeiten. Sie ist objektorientiert programmiert und läuft als Erweiterung der Unity Engine. 

\bild{projectOverview}{16cm}{Ansicht des Unity-Editors in einer typischen Szene}{Ansicht des Unity-Editors}

\bild{dungeons}{16cm}{Verschiedene in Unity generierte Dungeons, im Scene View betrachtet}{Verschiedene generierte Dungeons}

\section{Ziele der Implementierung}

Wie später in \ref{s.anwendungsmöglichkeiten} beschrieben, sind viele verschiedene Anwendungsszenarien für diesen Generator denkbar. 

Ein Ziel der Implementierung ist es, dass die Software nicht einen spezifischen Generator darstellt, sondern eine Software in der sich verschiedene Generatoren der gleichen Klasse konfigurieren lassen. Es sollten möglichst große Teile des Algorithmus nicht hard-coded sondern konfigurierbar sein, indem sie als Daten vorliegen. Insbesondere gilt das für das Alphabet und die Produktionsregeln der Array-Grammatik.

Ein weiteres Ziel ist es die Features der Unity-Engine zu nutzen, Insbesondere die Entity-Component-Architektur und die Möglichkeiten den Unity-Editor mit eigener UI zu erweitern. 

\section{Wichtige Unity-Features}

Unity verwendet eine Entity-Component-Architektur. So werden an ein GameObject beliebig viele Komponenten angehängt, die verschiedene Funktionen erfüllen und miteinander interagieren können. Dies ermöglicht einen modularen Aufbau von Objekten. 
\cite[Seite: GameObjects]{unityManual}
Neue Komponenten können in Unity programmiert werden, indem man eine Klasse schreibt, die von der Klasse MonoBehaviour erbt.
\cite[Seite: CreatingAndUsingScripts]{unityManual}

Ein Beispiel hierfür kann man in Abbildung \ref{img.screenshotGenerator} sehen, nur durch das Zusammenspiel der einzelnen Komponenten ergibt sich ein Generator. Durch den modularen Aufbau verhindert man zum einen Code Duplication (Es wird z.B. der PatternView auch in anderen Objekten wiederverwendet), zum anderen ist es eine Anpassungsmöglichkeit: So lässt sich nach Belieben ein RandomReplacer oder ein RecipeReplacer verwenden um verschiedenes Verhalten zu erzeugen. 

Manche Komponenten ließen sich prinzipiell zusammenfassen, wie z.B. PatternView und PatternToPrefabs, aber wurden trotzdem getrennt implementiert, da sie unterschiedliche Aufgaben erfüllen. Dies macht auch das Ausbauen der Software in der Zukunft einfacher, da einzelne Komponenten ausgetauscht oder umgeschrieben werden können, solange die öffentlichen Funktionen und Variablen dieser Komponenten gleich bleiben.

In Abbildung \ref{img.screenshotGenerator} sieht man auch gut ein weiteres wichtiges Unity-Feature, nämlich die Darstellung von öffentlichen Variablen im Inspektor. Ist ein Field public (oder private und mit dem SerializeField-Attribute gekennzeichnet) so kann der Wert dieses Fields im Inspektor gesetzt werden; Unity unterstützt hierbei gewisse Datentypen von Haus aus, für andere kann man sogenannte Property Drawers definieren. Alle Generator-Komponenten haben public Fields, was den ganzen Generator sehr konfigurierbar macht.

Teilweise wurde außerdem das User Interface über selbst geschriebene Editor-UI ausgebaut, mehr hierzu in Abschnitt \ref{s.editorUI}.

\section{Ordnerstruktur}

\todo{Namespaces!}

Die Ordnerstruktur des Projektes ist auf der höchsten Ebene in drei Ordner unterteilt: EasyButtons, ReplaceDungeonGenerator und Game.

EasyButtons ist ein Package, dass das einfache Erstellen von Buttons im Inspektor zum Aufrufen von Methoden des Components erlaubt. \todo{ref zu materialien}.

ReplaceDungeonGenerator enthält die Kern-Assets des Generators. Dieser Ordner kann in jedes Projekt eingefügt werden. Dieses Package hat lediglich EasyButtons als Dependency. Somit lässt sich der Generator einfach in anderen Projekten einsetzen ohne unnötige Assets wie Modelle, PlayerController, etc. mit zu Importieren.

Game enthält alle Spiel-spezifischen Assets, die nicht Teil des Generator-Kerns sind.

Innerhalb dieser Ordner wird nach Asset-Typ unterschieden (Scenes, Models, Scripts, ...). Ordner, die Editor heißen, werden nur für den Editor gebraucht und darin enthaltene Assets sind im fertigen Spiel nicht verwendbar.

Weitere Unterordner wurden nach Bedarf erstellt, wie z.B. um die Modelle von zwei Generations-Stilen (Rooms und DiagonalRooms) zu unterscheiden.

\section{Aufbau des Generator-Objekts}

Das wichtigste GameObject der Software ist der „Generator“, dieser ist üblicherweise zusammengesetzt aus folgenden Komponenten: 
Transform (Bestandteil von jedem GameObject), PatternView, RandomReplacer oder RecipeReplacer, RuleSet, RuleEditor (optional), ReplacementEngine, PatternToPrefabs. 

\bild{screenshotGenerator}{12cm}{Screenshots des Inspektors eines Generator-GameObjects, man sieht alle vorhandenen Komponenten und deren Einstellungen}{Screenshot der Generator-Komponenten}

Es folgt eine kurze Beschreibung der einzelnen Components. Es wird dabei hauptsächlich auf die Funktion und Bedienung der Components eingegangen, nicht auf Implementierungsdetails.

\subsection{PatternView}\label{ss.patternView}

Das PatternView repräsentiert einen dreidimensionalen Array von Labels. Diese Labels stehen üblicherweise für einen Raum und eine Rotation. Das Label „st\_2“ steht beispielsweise für eine gerades Stück („st“ für „straight“), dass um zwei mal um die y-Achse rotiert wurde. Das PatternView enthält außerdem ein Display Delta, dass bestimmt mit wie viel Abstand die Räume im Raum verteilt sind. Im Scene View\footnote{Übersicht der Unity-UI: \cite[Seite: LearningtheInterface]{unityManual}} von Unity werden die Labels als Text im dreidimensionalen Raum angezeigt (erkennbar in Abb. \ref{img.sceneView1}).

\bild{sceneView1}{16cm}{Sicht auf einen Teil eines generierten Dungeons im Unity Scene View}{Dungeon-Teil im Unity Scene View}

\subsection{PatternToPrefabs}

Der PatternToPrefabs Component ist ein Component, der für jedes Label im PatternView ein oder mehrere Prefabs in der Szene erstellt. Dies geschieht wenn eine Änderung im PatternView stattfindet und einmal bei Spielstart. In einem ScriptableObject\footnote{Scriptable Objects in Unity: \cite[Seite: class-ScriptableObject]{unityManual}} der Klasse PrefabDictionary wird jedem Raumnamen wie „st“ ein Prefab\footnote{Prefabs in Unity: \cite[Seite: LearningtheInterface]{unityManual}} zugeordnet. 

Es können beliebig viele Raumnamen mit Unterstrichen getrennt in einem Label vorkommen, die zugehörigen Prefabs werden dann übereinander generiert. die Kette kann mit einer Zahl beendet werden, die die Rotation in $90^\circ$-Schritten um die y-Achse angibt. Ein Beispiel hierfür ist „it\_obstacle\_0“ in Abbildung \ref{img.sceneView1}. Es wird das Kreuzung-Prefab „it“ mit einem Hindernis-Prefab „obstacle“ generiert und um 0 mal $90^\circ$ gedreht.

Der PatternToPrefabs Component verlangt ein PatternView Component mit RequireComponent\footnote{RequireComponent in Unity: \cite[Seite: RequireComponent]{unitySciptingReference}}

\subsection{ReplacementEngine}

Die ReplacementEngine ist verantwortlich für die im Hintergrund stattfindende Ersetzung. Sie findet im PatternView Matches für Regeln aus dem RuleSet. Erhält sie von einem anderen Component wie RandomReplacer das Signal, wendet sie eine Produktionsregel an. Dabei kann eingestellt werden ob an einer zufälligen Position, der zuerst gefundenen, oder zuletzt gefundenen Position ersetzt werden soll. Es kann außerdem ein Filter übergeben werden, sodass nur bestimmte Regeln ersetzt werden. Dieser Filter wird vom RecipeReplacer verwendet.

Der PatternToPrefabs Component verlangt die PatternView und RuleSet Components mit RequireComponent.

\subsection{RandomReplacer und RecipeReplacer}

Es gibt zwei verschiedene Replacer: Den RandomReplacer und den RecipeReplacer. Beide Replacer erfüllen die selbe Funktion, sie dienen als Haupt-Schnittstelle des Generators. Von ihnen kann die Generation ausgelöst werden.

Dies ist zu Testzwecken im Unity Editor möglich, indem man auf den Generate-Knopf drückt, oder zur Laufzeit indem man die Generate-Methode aufruft. Die Generate-Methode generiert einen ganzen Dungeon auf einmal. Alternativ kann man auch einmal die InitializeGeneration-Methode aufrufen und im Anschluss die GenerateStep-Methode um einzelne Ersetzungen Schritt für Schritt vorzunehmen.

Der RandomReplacer ist die simplere Variante der beiden Replacer. Er wählt immer eine zufällige Position und Regel für den nächsten Produktionsschritt. Dabei gewichtet er die einzelnen Positionen gemäß der Gewichtung der Regeln im RuleSet.

Der RecipeReplacer verwendet eine Recipe-Datei des Datentypen TextAsset\footnote{Text Assets in Unity: \cite[Seite: class-TextAsset]{unityManual}}. In der Text-Datei ist festgelegt in welcher Reihenfolge die Regeln aus RuleSet angewandt werden. Das genaue Format des Recipes ist in \ref{s.recipeFormat} beschrieben.

\subsection{RuleSet}

Das RuleSet ist der Component in dem alle Produktionsregeln enthalten sind. Die Inspektor-UI dieses Components enthält die Möglichkeit Regeln im JSON-Format zu laden und zu speichern. Es lassen sich Regeln entfernen, hinzufügen und auswählen. Ist eine Regel ausgewählt, kann sie im RuleEditor-Component editiert werden (vorausgesetzt es ist ein RuleEditor an das GameObject angehängt).

Das RuleSet ist nur im Namen ein Set, nicht im informatischen Sinne. Ein Set wäre ungeordnet, das RuleSet allerdings enthält eine Liste an Regeln. Die Reihenfolge der Regeln in der Liste kann in bestimmten Fällen eine Rolle spielen, etwa wenn in der ReplacementEngine die „Replacement Strategy“ auf „First“ oder „Last“ gesetzt ist.

\subsection{RuleEditor}\label{ss.ruleEditor}

Der RuleEditor ist ein Component der zum editieren von Regeln verwendet wird. 

\bild{screenshotRuleEditor}{8cm}{Inspektor des RuleEditor-Components}{Inspektor des RuleEditor-Components}

Ist im RuleSet eine Regel ausgewählt, enthält der RuleEditor-Inspektor die Einstellungen für genau diese Regel. Es können Parameter wie Name und Gewichtung der Regel gesetzt werden. Außerdem eine maximale Anzahl an Anwendungen dieser bestimmten Regel und und eine Anzahl an „Wait Steps“. Der Generator wendet die Regel nicht an bevor nicht so viele Generationsschritte vergangen sind.

Ist der Toggle „Obey rule orientation“ aktiv, werden für diese Regel intern vier Regeln generiert, eine für jede Himmelsrichtung. Dieses Feature existiert, da Menschen instinktiv nicht zwischen Himmelsrichtungen unterscheiden, und somit die meisten Regeln um die y-Achse rotiert auch angewendet werden können. Ist der toggle angeschaltet kann die rotation auch per Knopfdruck geändert werden. 

Ist der Toggle „Reversible“ aktiv, so kann die Regel nicht nur angewendet, sondern auch rückgängig gemacht werden. Hierfür wird im Hintergrund eine inverse Regel erstellt, bei der die linke und rechte Seite vertauscht sind. Dies kann schnell zu Fluktuationen im Generator führen, wobei eine Regel in aufeinanderfolgenden Schritten widerholt angewandt und rückgängig gemacht wird. Deshalb sollte dieses Feature bewusst verwendet werden.

Die linke und rechte Seite der Regeln werden hier in Textfeldern angegeben. Da diese Seiten  dreidimensionale Arrays sind ist die Eingabemethode nicht trivial. Es wurde eine eindimensionale Darstellung des dreidimensionalen Arrays gewählt. Die Symbole Semikolon, Komma und Leerzeichen Brechen jeweils in die nächste Dimension um. Die in Abbildung \ref{img.ruleEditorExample} abgebildete Regel liegt z.B. in der xz-Ebene, da Semikolon in x-Richtung trennt und Leerzeichen in z-Richtung. Die Regeln lesen sich auf dem Screenshot von unten nach oben (z) und von links nach rechts (x).

\bild{ruleEditorExample}{16cm}{Beispiel einer Produktionsregel in Unity mit linker und rechter Seite und den dazugehörigen String-Darstellungen. Die verwendeten Symbole sind „st“ (straight), „tl“ (turn left) und „tr“ (turn right). Die Pfeile bezeichnen die vorgesehene Begehungsrichtung und sind nur im Scene View sichtbar. }{Beispiel einer Produktionsregel in Unity}

Dieses Format ist nicht wirklich intuitiv, wurde aber aus Gründen von Aufwands/Nutzen-Erwägungen so belassen. Eine mögliche Verbesserung findet sich in \ref{s.verbesserungen}.

\section{Wichtige Klassen}

Es gibt auch einige Klassen, die keine Components, aber trotzdem erwähnenswert sind. Die Klassen Tile, Pattern und Rule sind mit dem Attribut System.Serializable markiert, was bedeutet, dass sie serialisiert werden können, ohne von MonoBehaviour oder ScriptableObject zu erben. Die Serialisierung ist notwendig, damit diese Klassen von Unity intern gespeichert werden können.
\footnote{Serialisierung in Unity: \cite[Seite: script-Serialization]{unityManual}}

\subsection{Tile}

Das Tile repräsentiert einen einzelnen Raum im dreidimensionalen Array. Diese Klasse ist ein Wrapper um einen read-only string, der das Label des Raumes darstellt, und hat zusätzliche Convenience-Funktionen, wie z.B. statische read-only Variablen für besondere Tiles (Empty, Wildcard, OutOfBounds).

\subsection{Pattern}

Das Pattern stellt einen dreidimensionalen Array von Tiles dar. Diese Wrapper-Klasse erledigt einige Aufgaben. Zum einen implementiert diese Klasse die Serialisierung des mehrdimensionalen Arrays, die Unity nicht standardmäßig durchführt. Die Pattern-Klasse besitzt mehrere Konstruktoren, z.B. um ein Pattern mit einer bestimmten Größe, gefüllt mit einem bestimmten Tile zu erzeugen, oder ein Pattern als Kopie eines anderen Patterns zu erzeugen. 

Außerdem gibt es die Methode RotatePattern90Y, die eine um $ 90^\circ $ um die y-Achse rotierte Kopie des Patterns zurückgibt. Diese Methode wird benutzt um die in \ref{ss.ruleEditor} erwähnte „obey rule orientation“ Funktionalität des RuleEditors zu ermöglichen. Diese Methode könnte auch für andere Permutationen ausgebaut werden, aber für den Großteil der Anwendungsszenarien ist dies ausreichend, da Gravitation üblicherweise in y-Richtung wirkt, was bedeutet, dass Räume häufig um die y-Achse drehbar sein müssen, jedoch nicht in andere Richtungen.

Des weiteren stellt das Pattern die Methoden GetTile und SetTile zur Verfügung um Tiles an gegebenen Positionen im Gitter erhalten und zu modifizieren. Diese Methoden führen einen Bounds-Check durch, um IndexOutOfRangeExceptions zu vermeiden, ein Bounds-Check in anderen Teilen des Programms wird damit überflüssig. Wird eine Position außerhalb des Patterns abgefragt wird stattdessen das spezielle OutOfBounds-Tile zurückgegeben.

Patterns finden sowohl als Datenstruktur des gesamten Dungeons Verwendung, als auch als auch als Datenstruktur der linken und rechten Seiten in Regeln. Sie werden auch zur puren Visualisierung verwendet z.B. um im Editor die linke und rechte Seite einer Regel zu visualisieren, die geschieht dann mit Hilfe eines PatternViews (\ref{ss.patternView}: PatternView).

\subsection{Rule}

Die Klasse Rule implementiert eine einzelne Produktionsregel. Wie schon im theoretischen Teil beschrieben besteht eine Produktionsregel aus einer linken und rechten Seite, diese Seiten sind jeweils ein Objekt der bereits beschriebenen Pattern-Klasse.

Des weiteren enthält sie ein Field für den Namen der Regel und folgende Felder für Einstellungsmöglichkeiten: weight, strictRotation, maximumApplications.

Die Klasse ist Serializable, dennoch gibt es außerdem die Klasse SerializedRule; diese wird verwendet, wenn die Klasse für Menschen lesbar serialisiert werden soll, insbesondere für das Speichern eines RuleSets im JSON-Format. 

\subsection{Utils}

Die Klasse Utils ist eine statische Utility-Klasse, die ein paar häufig verwendet Funktionen beinhaltet, die zu keiner bestimmten anderen Klasse zugehörig sind.

Sie enthält verschiedene Funktionen für Vector3Int: Clamping, Bounds-Checking, Bounds-Überschneidung und Iteration über ein einen dreidimensionales Gitter.

Außerdem eine Funktion für gewichteten Zufall, eine Funktion um ein Child-Objekt in der Hierarchie einzigartig zu erzeugen. Eine Funktion um Labels im Scene View im dreidimensionalen Raum zu zeichnen und ein Tool, dass Mesh Collider für Objekte mit bestimmter Benennung hinzufügt (Speziell für mit der Software „Asset Forge“ erstellte Modelle).

\section{Optimierungen des Pattern Matchings}

Der in \ref{s.speziellerAlgorithmus} beschriebene Ersetzungs-Algorithmus verlangt, dass bei der Anwendung einer Produktionsregel die linke Seite einer Regel im Dungeon-Array gefunden werden muss.

In einem Generations-Schritt müssen zuerst alle möglichen Ersetzungen gefunden werden, damit dann eine zufällige ausgewählt werden kann. Der Algorithmus zum finden der Matches sieht so aus:

\begin{verbatim}
    D := Pattern des Dungeons
    R := Regeln
    ls(r) := Pattern der linken Seite einer Regel r
    tile(P, p)

    für alle Positionen p1 in D:
        für alle Regeln r in R:
            für alle Positionen p2 in ls(r):
                wenn tile(p1 + p2, D) != tile(p2, ls(r)))
                    return false
\end{verbatim}

\todo{Den Algorithmus mal richtig schreiben}

Dieser Algorithmus selbst ist relativ aufwändig, und schwer zu optimieren. 

Aber eine einfache Art und Weise die Generierung insgesamt schneller zu machen ist diese Suche nicht jeden Schritt auf dem ganzen Dungeon durchzuführen. Stattdessen wird nur im ersten Schritt das gesamte Dungeon-Pattern durchsucht, gefundene Matches werden in einer Liste gespeichert. Wird in darauf folgenden Schritten eine Ersetzung durchgeführt wird nur die Gegend um das eben ersetzte Stück als „schmutzig“ angesehen. Matches die mit dieser Gegend überschneiden werden aus der Liste gelöscht und die Gegend wird erneut nach Matches durchsucht. 

Die Liste der momentan gefundenen Matches kann so schön visualisiert werden, wie in Abbildung \ref{img.screenshotReplacementVisualisation} zu erkennen.

\bild{screenshotReplacementVisualisation}{16cm}{Visualisierung aller momentan gespeicherten Matches als gelbe Boxen mit zugehöriger Regel.}{Visualisierung gefundener Matches}

\section{Editor UI}\label{s.editorUI}

Zur einfacheren Konfiguration und zum schnelleren iterieren wurde der Generator so geschrieben, dass er im Editor ausgeführt werden kann und der Unity-Editor wurde mit zusätzlicher UI ausgestattet.

Die einfachste Art und Weise dies zu ermöglichen ist das Open Source Package EasyButtons. Es ermöglicht Buttons über ein Attribut zu Funktionen hinzuzufügen.

% check float in the end here
% if necessary add caption here with caption=...
\begin{lstlisting}[label=l.buttonAttribute, caption={Beispiel eines EasyButtons-Attributs}] 
[EasyButtons.Button]
public void InitializeGeneration()
{
    //...
}
\end{lstlisting}

Diese Buttons werden dann am Anfang des Inspectors eingefügt (siehe Abb. \ref{img.screenshotRecipeReplacer}). Dies ist eine einfache Variante einen Inspektor auszubauen, ohne eine zusätzliche Klasse zu definieren.

\bild{screenshotRecipeReplacer}{8cm}{Screenshot des RecipeReplacer Components. Am Anfang des Inspektors sind die mit EasyButtons generierten Buttons zu sehen}{Screenshot des RecipeReplacer Components}

Für andere Editor-Funktionalität musste der Inspektor weiter ausgebaut werden. In diesem Fall schreibt man einen Custom Editor und implementiert die Methode OnInspectorGUI
\footnote{Benutzerdefinierte Editoren in Unity: \cite[Seite: editor-CustomEditors]{unityManual}}.

Die drei Komponenten PatternView, RuleEditor und RuleSet haben benutzerdefinierte Inspektoren. PatternView hat einen simplen benutzerdefinierten Inspektor zum ändern der Größe des Patterns, da der normale Vector3Int Property Drawer hierfür nicht verwendet werden konnte. 

Für das RuleSet wurde eine Editor geschrieben um die Unity-Klasse ReorderableList zu nutzen. Mit dieser Klasse kann eine Listenansicht erzeugt werden, die hinzufügen, entfernen und umordnen von Einträgen einer Liste möglich macht. Hiermit wird das hinzufügen von neuen Regeln und das umordnen von Regeln einfacher gemacht (Listenansicht zu sehen in Abb. \ref{img.screenshotGenerator}). Außerdem kann der Benutzer eine Regel auswählen. Die ausgewählte Regel kann dann im RuleEditor-Component editiert werden.

Der RuleEditor hat auch einen Custom Editor, da hier die Eigenschaften der aktuell ausgewählten Regel angezeigt werden. Ein Custom Editor ist notwendig um die Regel zu editieren, die keinen eigenen Editor hat. Außerdem werden hier die in \ref{ss.ruleEditor} bereits erklärten String-Darstellungen der linken und rechten Seite der Regel in Arrays umgewandelt. \todo{bloß schöner schreiben}

Des weiteren implementieren einige Components die OnGizmosDraw Methode (siehe \cite[Seite: MonoBehaviour.OnDrawGizmos]{unitySciptingReference}) um ihre eigenen Grafiken im SceneView zu zeichnen. 

\bild{screenshotGizmos}{16cm}{Beispiel von benutzerdefinierter Visualisierung im Scene View: Pfeile, die die Raumdurchquerungsrichtung angeben, Schlösser- und Schlüssel-Indikatoren, Boxen die die Positionen von bestimmten Patterns anzeigen und Labels, die Matches und Räume bezeichnen.}{Beispiele für benutzerdefinierte Gizmos}

\section{Regelsystem}
\section{Recipe-Format}\label{s.recipeFormat}



\section{Spielmechaniken}

Um den Dungeon-Generator zu demonstrieren wurden ein paar rudimentäre Spielmechaniken implementiert. Startet man das Spiel wird ein Dungeon generiert und der Spieler erscheint im Start-Raum des Dungeons.

Der Spieler kann sich in einer First-Person-Perspektive mit der Maus umschauen und mit dem WASD-Tasten herumlaufen. Mit der Leertaste kann gesprungen werden (auch in der Luft, was nur zu Testzwecken getan werden sollte).

Mit der rechten Maustaste kann mit Objekten interagiert werden, interaktive Objekte werden mit einem Text auf dem Bildschirm gekennzeichnet. Mit der linken Maustaste können Würfel geschossen werden, die nur zum Austesten von Kollision oder zum hinterlassen von Markierungen gedacht sind, aber keine Spiel-Funktion besitzen. Der Spieler kann so den Dungeon durchsuchen und die Geometrie von innen beurteilen. 

Es wurde ein Schlüssel-Schloss-System implementiert. Der Spieler kann im Dungeon Schlüssel finden und aufheben, die Anzahl der Schlüssel wird auf dem Bildschirm abgebildet. Hat der Spieler einen Schlüssel, so kann er diesen benutzen um eine Tür zu öffnen. Dieses System kann verwendet werden um zu testen, ob die Schlüssel-Schloss-Regeln richtig geschrieben worden, und keine Tür erzeugt wird ohne das davor im Dungeon auch ein Schlüssel erzeugt wurde.

Ein weiteres interaktives Objekt ist eine schwarze Box, die über einer Tür erzeugt und nur von einer Seite entfernt werden kann. 

Diese Spielmechaniken bilden natürlich kein richtiges Spiel ab, reichen aber aus um die Idee der erzeugten Dungeon-Struktur zu erkunden. Würde man den Generator für ein tatsächliches Spiel verwenden würde man die Dungeons mit diesem Spiel testen.

\section{Raum-Modelle}

Ähnlich wie die Spielmechaniken sind auch die Modelle der einzelnen Räume eher exemplarischer Natur. Diese Räume müssten für jedes Spiel individuell modelliert und gestaltet werden. 

Da die Räume als Prefabs vorliegen sollte es einem mit Unity vertrauten Level-Designer kein Problem sein die einzelnen Räume zu erstellen. Es muss lediglich darauf geachtet werden, dass die Räume and den Kanten perfekt zusammenpassen. Für diese Arbeit wurde das Programm Asset Forge verwendet um die Räume zu erstellen. Die Raumteile für Decken, Wände und Türbögen wurden in Blender modelliert. 

\bild{screenshotRoomPrefabs}{16cm}{Screenshot der Raum-Prefabs und des dazugehörigen PrefabDictionary im Project-Window}{Raum-Prefabs im Project-Window}

\chapter{Auswertung der generierten Dungeons}

Die Qualität der generierten Dungeons soll im Folgenden bewertet werden um das Verfahren zu beurteilen. 

\section{Einschränkungen}

Es ist zuerst zu sagen, dass eine objektive Bewertung der Dungeons schwer möglich ist. Dies hat mehrere Gründe.

Ein direkter Test mit Spielern und eine Auswertung über Fragebögen ist nicht möglich, da der Dungeon-Generator nicht für ein bestimmtes Spiel konzipiert würde. Mit einem Test-Spiel wäre dies jedoch ein guter Ansatz, wenn auch etwas aufwändig und nicht im Rahmen dieser Arbeit machbar.

Zweitens ist die Qualität von Dungeons prinzipiell subjektiv, was eine rein statistische Auswertung wenig aussagekräftig macht.

Drittens gibt es keine akzeptierten Standards für die Auswertung von Dungeons, was einen Vergleich mit anderen Verfahren schwer macht. Eine Vergleich von verschiedenen Verfahren wäre natürlich interessant, aber auch nicht Inhalt dieser Arbeit \todo{Verweis auf Ausblick o.ä.}

\section{qualitative Auswertung}

\section{quantitative Auswertung}

% evtl. Laufzeit betrachten. Evtl. statistische Metriken von Ähnlichkeit herausfinden

\section{Mögliche Verbesserungen}\label{s.verbesserungen}

% Mögl. Verbesserung: Statt Array eine unendlich große Struktur verwenden (Hash-Irgendwas?)

\section{Mögliche Anwendungsszenarien}\label{s.anwendungsmöglichkeiten}

Der Generator wurde konzipiert um and vielfältige Anwendungsszenarien angepasst werden zu können, es folgen eine kleine Auswahl. So soll eine kleiner Überblick über den durch diese Software abgedeckten Raum an möglichen Generatoren gegeben werden.

\subsection{Roguelike, Rogue-lite}

Das Genre der Roguelike-Spiele umfasst im engeren Sinne Spiele die direkt von dem Spiel „Rogue“ inspiriert sind und im weiteren Sinne Spiele, die die Charakteristiken Perma-Death und zufällig generierte Levels aufweisen. Spiele die nur diese Charakteristiken aufweisen ohne auf andere Art und Weise Rogue zu imitieren werden auch manchmal unter dem Begriff Rogue-lite zusammengefasst.

Roguelikes sind der klassische Anwendungsfall für Dungeon-Generatoren. Durch die Verwendung von zufällig generierten Dungeons wird in Roguelikes sichergestellt, dass der Fortschritt des Spielers durch meistern der Spielmechaniken stattfindet, nicht durch auswendig lernen der Levels. 

\todo{Regelsystem für eine Roguelike}

\subsection{Minigolf}

Minigolfspiele sind ein Genre an Casual Games, direkt inspiriert von realem Minigolf (korrekt „Bahnengolf“). Hier ist es das Ziel einen Golfball mit möglichst wenig Schlägen über eine Bahn in ein Loch zu befördern. Stärke und Richtung werden hierbei vom Spieler gesetzt. 

\todo{Regelsystem für eine Roguelike}

\subsection{Text Adventure}

Obwohl der Dungeon-Generator einen dreidimensionalen Raum verwendet, bedeutet dass nicht, dass zwangsläufig eine dreidimensionale visuelle Darstellung notwendig ist.

In einem Text Adventure ließt der Spieler Texte und trifft Entscheidungen, die wiederum weitere Texte auslösen. In klassischen Text Adventures werden diese Entscheidungen durch Texteingabe getroffen. In modernen Varianten sind die Entscheidungen häufig multiple choice.

\todo{Regelsystem für Text Adventure}

\todo{Regelszstem für Text Adventure Generator}

\chapter{Fazit}\label{c.zusammenfassung}



% Anhang
\chapter{Verwendete Materialien}

\LaTeX -Vorlage von Martin Bretschneider 
\newblock \url{https://www.bretschneidernet.de/tips/thesislatex-vorlagen.html#vorlagen}, 2006. --
\newblock letzter Zugriff: 08.01.2019

\todo{Easybuttons}
\todo{Dungeon-Tileset für Tür}
\todo{Asset Forge}

\bibliographystyle{alphadin_martin}
\bibliography{bibliographie}
\bibliographystyleimg{alphadin_martin}
\bibliographyimg{bildquellenverzeichnis}

\chapter{Erklärung}

Hiermit versichere ich, dass ich die vorliegende Arbeit selbstständig verfasst und keine anderen als die angegebenen Quellen und Hilfsmittel benutzt habe, dass alle Stellen der Arbeit, die wörtlich oder sinngemäß aus anderen Quellen übernommen wurden, als solche kenntlich gemacht und dass die Arbeit in gleicher oder ähnlicher Form noch keiner Prüfungsbehörde vorgelegt wurde.

\vspace{3cm}
Ort, Datum \hspace{5cm} Unterschrift \\

\end{document}